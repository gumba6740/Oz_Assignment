트랜잭션: 데이터베이스의 한 덩어리 작업. 개별 쿼리틀을 묶어서 한 단위로 성공시키거나 실패시킬 수 있다.

“””
START TRANSACTION;

queries;

COMMIT; 또는 ROLLBACK;
“””

START TRANSACTION 내부의 쿼리들은 DB에 반영되지 않고 임시상태에 들어감(만일 auto_commit 모드가 켜져 있어도 무시됨). 에러가 나더라도 자동으로 롤백되는 것은 아니고, 사용자가 쿼리 실행 결과를 보고 커밋 또는 롤백을 선택하여 입력.

커밋 시 데이터를 DB에 반영. 에러가 발생한 쿼리가 있을 때 커밋을 하게 되면 성공한 쿼리만 DB에 반영된다. 하지만 트랜잭션의 목적에 위배되므로 비추천
롤백을 하면 성공했든 실패했든 트랜잭션 이전 상태로 돌아간다.


* mysql은 기본 오토커밋이 켜져 있는 상태. set autocommit = 1;
끄면 커밋과 롤백으로 반영하거나 돌릴 수 있다. 그런데 컬럼명을 바꾸는 건 커밋을 안 해도 디비에 반영 됨. 내용을 수정하는 작업이 커밋이나 롤백의 대상이다. 
DDL(Data Definition Language)는 트랜잭션의 대상이 아님
DML(Data Manipulation Language) 트랜잭션의 대상
DCL (Data Control Language) 트랜잭션 대상 아님

mysql 기준. dbms의 종류에 따라 다를 수 있다




트랜잭션의 ACID: 트랜잭션의 성질을 나타내는 4가지 키워드
 - Atomicity(원자성): 쪼갤 수 없는 단위
 - Consistency(일관성): 규칙을 어기지 않는 상태. 트랜잭션 실행 전후의 상태는 데이터타입, 데이터 조건, 비즈니스 로직 등의 규칙을 준수해야 한다.
 - Isolation(고립성): 동시에 실행되는 트랜잭션들이 서로 간섭하지 못함
 - Durability(지속성): 커밋된 데이터는 DB에 영구반영됨.


고립성의 4 단계
1. read uncommitted: 커밋되지 않은 트랜잭션을 다른 트랜잭션이 읽을 수 있음. ex)송금 트랜잭션이 커밋되지 않았는데도 예금조회 트랜잭션으로 변경된 결과를 볼 수 있음

2. read committed: 커밋이 완료된 데이터를 읽을 수 있음(가장 많이 쓰임)
3. repeatable read: 읽기 트랜잭션이 시작되기 전에 커밋된 내용만 볼 수 있음. 
 * 하나의 읽기 트랜잭션에 여러 읽기쿼리가 있을때, rc는 데이터의 변경값을 트랜잭션 내에서 읽을 수 있음. rr은 읽기 트랜잭션 중간에 변경된 데이터를 읽지 못함

4. serializable: 트랜잭션을 순차적으로 실행. 가장 엄격







무결성: 데이터가 정확하고, 일관되고, 신뢰할 수 있게 유지되는 성질

1. 엔티티무결성: pk는 각 레코드를 유일하게 식별할 수 있어야 하므로
 			NULL이면 안됨, 중복되면 안됨, 한 레코드에 하나씩 넣어줘야함

2. 참조무결성: 외래키가 참조하는 값은 반드시 부모테이블에 존재해야함.  외래키가 보통 pk를 참조하는 이유. 이론적으로는 pk가 아니어도 참조는 가능. 

* ON DELETE CASCADE ON UPDATE CASCADE로 부모키의 상태를 따라갈 수 있다. 부모키를 찾을 수 없는 고아레코드 방지

3. 도메인 무결성: 각 컬럼에 저장될 수 있는 값의 범위를 제한해서 의미 없는 데이터가 들어오지 못하게 하는 규칙.
  ex) 나이 컬럼에 음수값을 넣는 등의 상황을 방지
 데이터 타입, NUT NULL, CHECK, ENUM, DEFAULT 등을 사용

4. 사용자정의 무결성: 엔티티, 참조, 도메인 무결성만드로는 표현할 수 없는 없무 규칙을 사용자가 직접 정의하여 지키게 하는 무결성
 CHECK 등을 사용







동시성 제어
 트랜잭션의 고립성을 지켜서, 일관성을 깨지 않도록 제어하는 방법

여러 트랜잭션이 같이 접근하면 발생하는 문제:
 - 서로의 업데이트를 덮어씀
 - 커밋이 안 된 데이터를 읽음
 - 같은 조회 쿼리의 결과가 달라짐


1. Lock 기반 동시성 제어
트랜잭션이 실행되면 락을 걸어 데이터를 보호.기본적으로 필요한 만큼만 건다. 레코드 단위, 여러 레코드(페이지) 단위, 테이블 단위로. 트랜잭션의 고립성을 강력히 보장

—S  Lock(shared Lock): 다른 트랜잭션의 쓰기는 불허하되 읽기는 허용하는 락.
 만일 쓰기 트랜잭션이 채 변경하지 않은 데이터에 읽기 트랜잭션이 접근하고 있으면, 쓰기 트랜잭션은 대기상태. 읽기 트랜잭션끼리는 대기 없음. 만약 다수의 읽기 트랜잭션이 데이터에 접근한다면 쓰기 트랜잭션의 대기시간이 길어지는 문제.

—X Lock(Exclusive Lock): 다른 트랜잭션의 읽기와 쓰기를 모두 막는 락



2. MVCC(다중 S버전 동시성 제어)
 다중버전: 하나의 데이터에 여러 버전이 동시에 존재
 s버전: 트랜잭션이 보는 시점의 스냅샷 버전
 다중 s버전: 하나의 데이터에 여러 시점의 스냅샷이 공존하는 것

다중 버전이란, 커밋되지 않은 트랜잭션과 기존 커밋된 기록이 공존하는 상태. 

기본적으로 MVCC도 쓰기는 하나의 트랜잭션만 가능하도록 락을 건다. 하지만 읽기에 대한 고립성을 완화하여 다수의 읽기 트랜잭션이 접근 가능. 읽기를 하는 동안 쓰기 트랜잭션은 방해받지 않고 작업 수행(lock 기반보다 고립성을 완화한 형태)




낙관적/비관적 동시성 제어
 - 낙관적: 남이 나를 방해하지 않을 것이라 가정하고, 락을 걸지 않은 상태로 트랜잭션을 실행. 트랜잭션 종료 시점에 충돌 검증 수행. 충돌이 있었을 시 롤백. 고립성을 매우 완화한 제어 방식.

충돌 가능성이 낮은 환경에서 효율적

충돌이란, 데이터의 일관성을 깰 가능성이 있는 동시 접근. 읽기는 일반적으로 충돌 아님

비관적: 미리 락을 건 상태로 트랜잭션 실행



4. Deadlock 관리
 - Deadlock: 두 개 이상의 트랜잭션이 서로 상대방의 락을 기다리면서 무한 대기 상태에 빠지는 상황.

ex) t1과 t2가 각자 자신이 점유한 자원을 잠금. 각 트랜잭션이 서로 점유한 자원에 접근요청. 작업이 완료돼야 어느 한 쪽의 락이 풀리는데, 그렇지 못해 교착상태

관리방법:
 1. 예방. 애초에 데드락이 발생하지 않도록 막는 방법. 동시성 낮음
   -  점유와 대기 금지: 트랜잭션 시작 전에 필요한 모든 락을 한번에 확보하는 방식.
   - 순환 대기 방지: 자원에 번호를 매기고, 번호 순서대로 락을 획득. 트랜잭션에도 우선순위를 만들어서 누가 먼저 1번 자원에 접근할 것인지도 결정. 락을 건 자원에 대한 요청이 끝나면 락 해제하여 다른 트랜잭션이 진행 가능

 2. 회피
  - 데드락이 발생할 가능성이 있는 요청을 미리 검사. 트랜잭션 우선순위를 부여하고, 우선순위 낮은 트랜잭션은 대기하지 않고 롤백

 3. 탐지와 회복: 데드락이 발생한 이후 일부 트랜잭션 롤백으로 풀어주는 방법. 동시성 높음